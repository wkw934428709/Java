
/*
策略模式：
1.设计原则
找出应用中需要变化的地方，把它独立出来，不要和那些不需要变化的代码混在一起

===========
换句话说，如果每次新的需求一来，都会使某方面的代码发生 变化，那么你就可以确定，这部分的代码需要被抽出来，和其 他稳定的代码有所区分。
下面是这个原则的另一种思考方式:“把会变化的部分取出并 封装起来，以便以后可以轻易地改动或扩充此部分，而不影响不需要变化的其他部分”。
这样的概念很简单，几乎是每个设计模式背后的精神所在。所有的模式都提供了一套方法让“系统中的某部分改变不会影响 其他部分”。
好，该是把鸭子的行为从Duck类中取出的时候了!
===========

即把鸭子的飞行和叫抽出来，它们变化太多，直接写在Duck中，所有子类都有该功能，不好。
但如果用接口单一实习，代码复用率太太太低。

2.设计原则
针对接口编程，而不是针对实现编程
所以我们针对flyBehavior分别实现了多个类。

===========
所以这次鸭子类不会负责实现Flying与Quacking接口，反而是由 我们制造一组其他类专门实现FlyBehavior与QuackBehavior，这 就称为“行为”类。由行为类而不是Duck类来实现行为接口。
这样的做法迥异于以往，以前的做法是:行为来自Duck超类的 具体实现，或是继承某个接口并由子类自行实现而来。这两种 做法都是依赖于“实现”，我们被实现绑得死死的，没办法更 改行为(除非写更多代码)。
在我们的新设计中，鸭子的子类将使用接口(FlyBehavior与 QuackBehavior)所表示的行为，所以实际的“实现”不会被绑 死在鸭子的子类中。(换句话说，特定的具体行为编写在实现了 FlyBehavior与QuakcBehavior的类中)。
===========

最后我们添加了一个动态设定的行为，这样可以充分体现出这样的设计模式的好处


*/

public class Main {
	public static void main(String[] args) {
		Duck mallardDuck = new MallardDuck();
		mallardDuck.performFly();
		mallardDuck.performQuack();

		mallardDuck.setFlyBehavior(new FlywithRocket());
		mallardDuck.performFly();
	}
}